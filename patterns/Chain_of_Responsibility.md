## Паттерн Chain of Responsibility (Цепочка обязанностей)
#### Название и классификация
   * *Название:* цепочка обязанностей - chain of Responsibility
   * *Тип:* паттерн поведения
#### Назначение
  * *Функция паттерна:* позволяет передавать запросы последовательно по цепочке обработчиков, пока его не обработают
  * *Обоснование и назначение*: Он позволяет разорвать связь между отправителями и получателями, дав возможность обработать запрос нескольким объектам. Запрос перемещается по цепочке объектов, пока один из них не обработает его.
#### Мотивация использования
  * Сценарий: контекстно-зависимая оперативная справка в графическом интерфейсе пользователя, который может получить дополнительную информацию по любой части интерфейса, просто щелкнув на ней мышью. Содержание справки зависит от того, какая часть интерфейса и в каком контексте выбрана. Например, справка по кнопке в диалоговом окне может отличаться от справки по аналогичной кнопке в главном окне приложения. Если для некоторой части интерфейса справки нет, то система должна показать информацию о ближайшем контексте,
в котором она находится, например о диалоговом окне в целом.
  * Такую справочную информацию удобнее организовать с иерархией от более конкретных разделов к более общим. (Такой запрос на получение справки обрабатывается одним из нескольких объектов пользовательского интерфейса, каким именно - зависит от контекста и имеющейся в наличии информации.)
  * Проблема: инициирующий запрос (например, кнопка), не располагает информацией об объекте, предоставляющем справку.
  * Необходимо: найти способ отделения кнопки-инициатора запроса от объектов, владеющих справочной информацией. 
  * Решение: использование паттерна цепочка обязанностей. 
#### Применимость
  * Необходимость многоступенчатой проверки
  * Иерархическая структура доступа к данным
#### Структура
![](https://github.com/MarinaSvistunova/prog5/blob/master/img/chain.png)
#### Участники
  * Handler (HelpHandler) - обработчик: 
    - определяет интерфейс для обработки запросов; 
    - (необязательно) реализует связь с преемником; 
  * ConcreteHandler (PrintButton, PrintDialog) - конкретный обработчик: 
    - обрабатывает запрос, за который отвечает; 
    - имеет доступ к своему преемнику; 
    -  ConcreteHandler при возможности самостоятельной обработки обрабатывает запрос, или при невозможности направляет его своему преемнику; 
  * Client - клиент: 
    - отправляет запрос некоторому объекту ConcreteHandler в цепочке. 
#### Отношения
Клиент инициирует запрос -> запрос двигается по цепочке до тех пор, пока некоторый объект ConcreteHandler не возьмет на себя ответственность за его обработку. 
#### Результаты
  * ослабление связанности. Отправителю и получателю ничего неизвестно друг о друге, а включенному в цепочку объекту - о структуре цепочки. Объекты имею информацию только о ближайшем переемнике. Это упрощает взаимосвязи между объектами.
  * дополнительная гибкость при распределении обязанностей между объектами. Добавить или изменить обязанности по обработке запроса можно, включив в цепочку новых участников или изменив ее каким-то другим образом. Этот подход можно сочетать со статическим порождением подклассов для создания специализированных обработчиков; 
  * получение не гарантировано. Из-за отсутствия явного получателя нет и гарантий обработки запроса: он может достичь конца цепочки и пропасть. Необработанным запрос может оказаться и в случае неправильной конфигурации цепочки. 
#### Реализация
  * способы реализации цепочки преемников:
    - определить новые связи (обычно это делается в классе Handler, но можно и в ConcreteHandler); 
    - использовать существующие связи.
  * представление запросов. 
    - например, в случае класса HandleHelp, запрос жестко кодируется как вызов некоторой операции (переадресовывать можно только фиксированный набор запросов, определенных в классе Handler)
    - использовать одну функцию-обработчик, которой передается код запроса (скажем, целое число или строка). Так можно поддержать заранее неизвестное число запросов. Единственное требование состоит в том,' что отправитель и получатель должны договориться о способе кодирования запроса. Это более гибкий подход, но при реализации нужно использовать условные операторы для раздачи запросов по их коду. Кроме того, не существует безопасного с точки зрения типов способа передачи параметров, поэтому упаковывать и распаковывать их приходится вручную. 
    * автоматическое перенаправление запросов в языке Smalltalk (механизм doesNotUnderstand). Сообщения, не имеющие соответствующих методов, перехватываются реализацией doesNotUnderstand, которая может быть замещена для перенаправления сообщения объекту-преемнику. Поэтому осуществлять перенаправление вручную необязательно. Класс обрабатывает только запросы, в которых заинтересован, и ожидает, что механизм doesNotUnderstand выполнит все остальное. 
#### Известные применения
  * Паттерн цепочка обязанностей используется в нескольких библиотеках классов для обработки событий, инициированных пользователем. Класс Handler в них называется по-разному, но идея всегда одна и та же: когда пользователь щелкает кнопкой мыши или нажимает клавишу, генерируется некоторое событие, которое распространяется по цепочке. 
  * В каркасе графических редакторов Unidraw определены объекты Command, которые инкапсулируют запросы к объектам Component и Component View. Объекты Command - это запросы, которые компонент или вид компонента могут интерпретировать как команду на выполнение определенной операции. Это соответствует подходу «запрос как объект», описанному в разделе «Реализация». 
  * В ЕТ++ паттерн цепочка обязанностей применяется для обработки запросов на обновление графического изображения. Графический объект вызывает операцию InvalidateRect всякий раз, когда возникает необходимость обновить часть занимаемой им области. Но выполнить эту операцию самостоятельно графический объект не может, так как не имеет достаточной информации о своем контексте, например из-за того, что окружен такими объектами, как Scroller (полоса прокрутки) или Zoomer (лупа), которые преобразуют его систему координат. Это означает, что объект может быть частично невидим, так как он оказался за границей области прокрутки или изменился его масштаб. Поэтому реализация InvalidateRect по умолчанию переадресует запрос контейнеру, где находится соответствующий объект. Последний объект в цепочке обязанностей — экземпляр класса Window. Гарантируется, что к тому моменту, как Window получит запрос, недействительный прямоугольник будет трансформирован правильно. Window обрабатывает InvalidateRect, послав запрос интерфейсу оконной системы и требуя тем самым выполнить обновление. 
#### Родственные паттерны
Паттерн цепочка обязанностей часто применяется вместе с паттерном компоновщик. В этом случае родитель компонента может выступать в роли его преемника.
